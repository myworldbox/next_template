import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import { CoreEnum } from "./core/core_enum";
import "./globals.css";
import GraphNet from "./item/graph/graph_net";
import GraphMatrix from "./item/graph/graph_matrix";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {

  const Step = CoreEnum.Step;

  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        {children}

        <GraphMatrix focus="A" relations={
          [
            // { from: "B", to: "C", type: Step.prev },
            // { from: "A", to: "H", type: Step.prev },

            { from: "H", to: "I", type: Step.parallel },
            { from: "A", to: "B", type: Step.parallel },
            { from: "C", to: "D", type: Step.parallel },
            { from: "K", to: "L", type: Step.parallel },

            { from: "C", to: "B", type: Step.next },
            { from: "H", to: "A", type: Step.next },
            { from: "C", to: "E", type: Step.next },
            { from: "A", to: "G", type: Step.next },
            { from: "A", to: "F", type: Step.next },
            { from: "H", to: "J", type: Step.next },
            { from: "H", to: "K", type: Step.next },
            { from: "K", to: "M", type: Step.next },
          ]
        } />

        <GraphNet focus="A" relations={
          [
            { from: "B", to: "C", type: Step.prev },
            { from: "A", to: "H", type: Step.prev },

            { from: "H", to: "I", type: Step.parallel },
            { from: "A", to: "B", type: Step.parallel },
            { from: "C", to: "D", type: Step.parallel },
            { from: "K", to: "L", type: Step.parallel },

            { from: "C", to: "E", type: Step.next },
            { from: "A", to: "G", type: Step.next },
            { from: "A", to: "F", type: Step.next },
            { from: "H", to: "J", type: Step.next },
            { from: "H", to: "K", type: Step.next },
            { from: "K", to: "M", type: Step.next },
          ]
        } />

        <GraphNet focus="A" relations={
          [
            { from: "B", to: "C", type: Step.prev },
            { from: "A", to: "B", type: Step.prev },
            { from: "C", to: "D", type: Step.parallel },
            { from: "A", to: "E", type: Step.parallel },
            { from: "E", to: "F", type: Step.prev },
            { from: "F", to: "G", type: Step.parallel },
          ]
        } />

        <GraphNet focus="å¸é¦¬æ‡¿" relations={
          [
            { from: "å¸é¦¬é˜²", to: "å¸é¦¬æ‡¿", type: Step.next },
            { from: "å¸é¦¬æ‡¿", to: "çŽ‹å‡Œ", type: Step.parallel },
            { from: "å¸é¦¬æ‡¿", to: "æŸå¤«äºº", type: Step.parallel },
            { from: "å¸é¦¬æ‡¿", to: "è«¸è‘›äº®", type: Step.parallel },
            { from: "å¸é¦¬æ‡¿", to: "æ›¹çœŸ", type: Step.parallel },
            { from: "ç§¦ä¼¯å—", to: "æ›¹çœŸ", type: Step.next },
            { from: "æ›¹çœŸ", to: "æ›¹çˆ½", type: Step.next },
            { from: "æŸå¤«äºº", to: "å¸é¦¬å€«", type: Step.next },
            { from: "å¸é¦¬æ‡¿", to: "å¸é¦¬å¸«", type: Step.next },
            { from: "å¸é¦¬æ‡¿", to: "å¸é¦¬æ˜­", type: Step.next },
            { from: "å¸é¦¬æ‡¿", to: "å¸é¦¬äº®", type: Step.next },
            { from: "å¸é¦¬æ‡¿", to: "å¸é¦¬å€«", type: Step.next },
            { from: "å¸é¦¬æ‡¿", to: "å¸é¦¬é¦—", type: Step.next },
            { from: "å¸é¦¬æ‡¿", to: "å¸é¦¬ä¼·", type: Step.next },
            { from: "å¸é¦¬ä¼·", to: "å¸é¦¬è¦²", type: Step.next },
            { from: "å¸é¦¬è¦²", to: "å¸é¦¬ç¿", type: Step.next },
            { from: "å¸é¦¬å€«", to: "å¸é¦¬è‚", type: Step.next },
            { from: "å¸é¦¬æ˜­", to: "å¸é¦¬ç‚Ž", type: Step.next },
            { from: "å¸é¦¬æ˜­", to: "å¸é¦¬æ”¸", type: Step.next },
            { from: "å¸é¦¬ç‚Ž", to: "å¸é¦¬è¡·", type: Step.next },
            { from: "å¸é¦¬ç‚Ž", to: "å¸é¦¬å†", type: Step.next },
            { from: "å¸é¦¬ç‚Ž", to: "å¸é¦¬ç©Ž", type: Step.next },
            { from: "å¸é¦¬ç‚Ž", to: "å¸é¦¬ç‘‹", type: Step.next },
            { from: "å¸é¦¬ç‚Ž", to: "å¸é¦¬ä¹‚", type: Step.next },
            { from: "å¸é¦¬ç‚Ž", to: "å¸é¦¬è¶Š", type: Step.next },
            { from: "å¸é¦¬ç‚Ž", to: "å¸é¦¬é²", type: Step.next },
            { from: "å¸é¦¬ç‚Ž", to: "å¸é¦¬æŸ¬", type: Step.next },
            { from: "å¸é¦¬æŸ¬", to: "å¸é¦¬é„´", type: Step.next },
            { from: "å¸é¦¬ç¿", to: "å¸é¦¬é‚µ", type: Step.next },
            { from: "å¸é¦¬é‚µ", to: "å¸é¦¬è¡", type: Step.next },
            { from: "å¸é¦¬é‚µ", to: "å¸é¦¬å²³", type: Step.next },
            { from: "å¸é¦¬å²³", to: "å¸é¦¬èƒ", type: Step.next },
            { from: "å¸é¦¬è¡", to: "å¸é¦¬ä¸•", type: Step.next },
            { from: "å¸é¦¬è¡", to: "å¸é¦¬å¥•", type: Step.next },
            { from: "å¸é¦¬ç¿", to: "å¸é¦¬æ˜±", type: Step.next },
            { from: "å¸é¦¬æ˜±", to: "å¸é¦¬é“å­", type: Step.next },
            { from: "å¸é¦¬é“å­", to: "å¸é¦¬æ›œ", type: Step.next },
            { from: "å¸é¦¬æ›œ", to: "å¸é¦¬å¾·å®—", type: Step.next },
            { from: "å¸é¦¬æ›œ", to: "å¸é¦¬å¾·æ–‡", type: Step.next }
          ]
        } />

        <GraphNet focus="A" relations={
          [
            // ðŸ” Parallel relationships (bidirectional, non-hierarchical)
            { from: 'A', to: 'B', type: Step.parallel },
            { from: 'B', to: 'A', type: Step.parallel },
            { from: 'C', to: 'D', type: Step.parallel },
            { from: 'D', to: 'C', type: Step.parallel },
            { from: 'E', to: 'F', type: Step.parallel },
            { from: 'F', to: 'E', type: Step.parallel },
            { from: 'G', to: 'H', type: Step.parallel },
            { from: 'H', to: 'G', type: Step.parallel },

            // âª Prev chain (hierarchical)
            { from: 'A', to: 'C', type: Step.prev },
            { from: 'C', to: 'E', type: Step.prev },
            { from: 'E', to: 'G', type: Step.prev },
            { from: 'G', to: 'I', type: Step.prev },
            { from: 'I', to: 'K', type: Step.prev },
            { from: 'K', to: 'M', type: Step.prev },
            { from: 'M', to: 'O', type: Step.prev },
            { from: 'O', to: 'Q', type: Step.prev },
            { from: 'Q', to: 'S', type: Step.prev },
            { from: 'S', to: 'U', type: Step.prev },
            { from: 'U', to: 'W', type: Step.prev },
            { from: 'W', to: 'Y', type: Step.prev },

            // â© Next chain (nonlinear jumps)
            { from: 'B', to: 'D', type: Step.next },
            { from: 'D', to: 'F', type: Step.next },
            { from: 'F', to: 'H', type: Step.next },
            { from: 'H', to: 'J', type: Step.next },
            { from: 'J', to: 'L', type: Step.next },
            { from: 'L', to: 'N', type: Step.next },
            { from: 'N', to: 'P', type: Step.next },
            { from: 'P', to: 'R', type: Step.next },
            { from: 'R', to: 'T', type: Step.next },
            { from: 'T', to: 'V', type: Step.next },
            { from: 'V', to: 'X', type: Step.next },
            { from: 'X', to: 'Z', type: Step.next },

            // ðŸ§© Cross-links for complexity
            { from: 'A', to: 'J', type: Step.next },
            { from: 'C', to: 'L', type: Step.next },
            { from: 'E', to: 'N', type: Step.next },
            { from: 'G', to: 'P', type: Step.next },
            { from: 'I', to: 'R', type: Step.next },
            { from: 'K', to: 'T', type: Step.next },
            { from: 'M', to: 'V', type: Step.next },
            { from: 'O', to: 'X', type: Step.next },
            { from: 'Q', to: 'Z', type: Step.next },

            // ðŸ”„ Loopbacks using parallel (no contradiction)
            { from: 'Z', to: 'A', type: Step.parallel },
            { from: 'Y', to: 'B', type: Step.parallel },
            { from: 'X', to: 'C', type: Step.parallel },

            // ðŸ§  Forks and merges
            { from: 'D', to: 'I', type: Step.next },
            { from: 'F', to: 'K', type: Step.next },
            { from: 'H', to: 'M', type: Step.next },
            { from: 'J', to: 'O', type: Step.next },
            { from: 'L', to: 'Q', type: Step.next },
            { from: 'N', to: 'S', type: Step.next },
            { from: 'P', to: 'U', type: Step.next },
            { from: 'R', to: 'W', type: Step.next },
            { from: 'T', to: 'Y', type: Step.next }
          ]
        } />
      </body>
    </html>
  );
}
